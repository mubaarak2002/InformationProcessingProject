<html>
<!-- <head>
  <title>Brick Breaker</title>
	<meta charset="UTF-8" />
	<style>
		#gameScreen {
			border: 6px solid black;
		}
	</style>
</head> -->
<style>
  * {
    padding: 0;
    margin: 0;
  }
  canvas {
    background: rgb(181, 160, 56);
    display: block;
    margin: 0 auto;
  }

</style>
<div id="container"></div>
<body>
  <!-- <img id="tankImg" src="assets/tank.png"> -->

<canvas id="canvas"></canvas>
<!-- <script src="/socket.io/socket.io.js"></script> -->
<script>
    
// define global variables

// create canvas
let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");

//key controls
let rightPressed = false; //movement
let leftPressed = false;
let upPressed = false;
let downPressed = false;
let commaPressed = false;
let periodPressed = false;
let spacePressed = false;
let escPressed = false;
let enterPressed = false;
let qPressed = false;
let winner = "none";

function drawPoints(topLeft, topRight, bottomLeft, bottomRight) {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  
  ctx.fillStyle = "black";
  ctx.fillRect(topLeft[0], topLeft[1], -(topLeft[0] - topRight[0]), -(topLeft[1] - bottomLeft[1]));

}

function allowableMove(forbiddenSpaces, currentx, currenty, dx, dy) {
  let legalXMove = true;
  let legalYMove = true;
  forbiddenSpaces.forEach(function check(space, index){
      //given the lines are straight lines, a vertex will always define the maximum and minimum
      //x and y values. This means that we can establish that the new y value cannot be inside
      //the min/max y verticies if the new x value is also inside the min/max x verticies

      let nx = currentx + dx
      let ny = currenty + dy;
      let minx = space[0][0];
      let miny = space[0][1];
      let maxx = space[1][0];
      let maxy = space[1][1];

      space.forEach(function thing(vertex, index) {
 
        if (vertex[0] < minx) {
          minx = vertex[0];
        }
        if (vertex[0] > maxx) {
          maxx = vertex[0];
        }
        if (vertex[1] < miny) {
          miny = vertex[1];
        }
        if (vertex[1] > maxy) {
          maxy = vertex[1];
        }
      });
      
      if (ny < maxy && ny > miny && nx < maxx && nx > minx) {
        legalYMove = false;
      }
      if (nx < maxx && nx > minx && ny < maxy && ny > miny) {
        legalXMove = false;
      }
    });
  return[legalXMove, legalYMove];
}
            

// height of window for reference 
canvas.height = window.innerHeight; //lock to 4:3 aspect ratio
canvas.width = canvas.height * 1.33;


//inside this should be rectangles with 4 points inside it to define a rectangle where you cannot
//enter, thus you can make them as big or as little as you want. but if you make them too small,
//and dx/dy is bigger than the width, you could jump through a square
//eg: const forbiddenSpaces = [ [[1,1], [2,2], [3,3], [4,4]] ] 
//change this to "const", not "let"
let forbiddenSpaces = [];
//this is adding the wall boundaries to it:
//"+/- 2" is just to give the wall some non-zero thickness

//this is a square in the middle of edge length 50
//MUST BE OF THE FORMAT [ [top left], [top right], [bottom left], [bottom right] ]
forbiddenSpaces = [ 
                    [
                       [canvas.width/2 - 50, canvas.height/2 - 50],
                       [canvas.width/2 + 50, canvas.height/2 - 50],
                       [canvas.width/2 - 50, canvas.height/2 + 50],
                       [canvas.width/2 + 50, canvas.height/2 + 50]
                    ]
                  ];

// define arrays for tanks and bullets
let tanks = [];
let bullets = [];
let walls = [];
// TODO: draw arena borders
//stuff for key controls. Comment out if not using
document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false);

function keyDownHandler(e) {
    if(e.key == "Right" || e.key == "ArrowRight") {
        rightPressed = true;
    }
    else if(e.key == "Left" || e.key == "ArrowLeft") {
        leftPressed = true;
    }
    if(e.key == "Up" || e.key == "ArrowUp") {
        upPressed = true;
    }
    else if(e.key == "down" || e.key == "ArrowDown") {
        downPressed = true;
    }
    if(e.keyCode == 188) {
        commaPressed = true;
    }
    else if(e.keyCode == 190) {
        periodPressed = true;
    }
    else if(e.keyCode == 32) {
        spacePressed = true;
    }
    else if(e.keyCode == 27) {
        escPressed = true;
    }
    else if(e.keyCode == (13 || "Enter")) {
      // console.log("Enter pressed");
      enterPressed = true;
    }
    if(e.keyCode == 81) {
        qPressed = true;
    }
}

function keyUpHandler(e) {
    if(e.key == "Right" || e.key == "ArrowRight") {
        rightPressed = false;
    }
    else if(e.key == "Left" || e.key == "ArrowLeft") {
        leftPressed = false;
    }
    if(e.key == "Up" || e.key == "ArrowUp") {
        upPressed = false;
    }
    else if(e.key == "down" || e.key == "ArrowDown") {
        downPressed = false;
    }
    if(e.keyCode == 188) {
        commaPressed = false;
    }
    else if(e.keyCode == 190) {
        periodPressed = false;
    }
    else if(e.keyCode == 32) {
        spacePressed = false;
    }
    else if(e.keyCode == 27) {
        escPressed = false;
    }
    else if(e.keyCode == (13 || "Enter")) {
      // console.log("Enter pressed");
      enterPressed = false;
    }
    if(e.keyCode == 81) {
        qPressed = false;
    }
}

// define the Tank class
class Tank {
  constructor(x, y, accX, accY, colour, player, fire) {
    this.x = x;
    this.y = y;
    this.accX = accX;
    this.accY = accY;
    this.colour = colour;
    this.width = 40;
    this.height = this.width;
    this.angle = 0;     //angle of movement
    this.shotAngle = 0; //angle of shooting
    this.magnitude = 0;
    this.speed = 2;
    this.health = 100;
    this.player = player;
    this.fire = fire;
    this.lives = 3;
  }

  draw() {
    // ctx.save();  
    ctx.beginPath();
    this.angle = Math.atan2(this.accY, this.accX) + (Math.PI * 0.5);                     //tank object contains postion change info (here used to calculate direction of travel)
    // ctx.save();
    //draw treads
    ctx.fillStyle = "Black";
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.fillRect(-25, -15, 50, 30);
    ctx.rotate(-this.angle);
    ctx.translate(-this.x, -this.y);
    ctx.closePath();

    ctx.beginPath();
    //draw body
    ctx.arc(this.x, this.y, 0.5 * this.width , 0, Math.PI * 2);      //tank object contains position info (tank.x and tank.y mark centre of tank circle)
    ctx.fillStyle = this.colour;                        //tank object contains colour
    ctx.fill();
    ctx.closePath();

    ctx.beginPath();

    this.shotAngle = this.angle + Math.PI; //comment out if you want turret rotating independently
    //draw barrel
    ctx.translate(this.x, this.y);
    ctx.rotate(this.shotAngle);           
    ctx.fillStyle = "Green"; 
    ctx.fillRect(-2, -2, 4, 35);
    ctx.rotate(-this.shotAngle);          
    ctx.translate(-this.x, -this.y);
    ctx.closePath();
    // ctx.restore();
                        
  }

  move() {
    // Caculate angle and magnitude of movement based on the acceleration
    this.magnitude = Math.sqrt(this.accX * this.accX + this.accY * this.accY);
    this.angle = Math.atan2(this.accY, this.accX);

    // // Limit magnitude
    // if (this.magnitude >= 141) {
    //   this.magnitude = 141;
    // } else if (this.magnitude >= 100) {
    //   this.magnitude = 100;
    // } else if (this.magnitude >= 75) {
    //   this.magnitude = 75;
    // } else if (this.magnitude >= 50) {
    //   this.magnitude = 50;
    // } else if (this.magnitude >= 25) {
    //   this.magnitude = 25;
    // } else {
    //   this.magnitude = 0;
    // }

    // Update coordinates
    let nx = Math.cos(this.angle) * this.magnitude * this.speed;
    let ny = Math.sin(this.angle) * this.magnitude * this.speed;
    

    if (allowableMove(forbiddenSpaces, this.x, this.y, nx, ny)[0]) {

      this.x += nx;
    }
    if (allowableMove(forbiddenSpaces, this.x, this.y, nx, ny)[1]) {

      this.y += ny;
    }
    this.detectCollision();
    this.draw();
  }

  fireBullets() {
    if (this.fire == "1") {
      // check of the tank is allowed to shoot
      const bullet = new Bullet(this.x, this.y, this.shotAngle, 10, 2, "black", this);
      bullets.push(bullet); // add the bullet to the bullets array
    }
  }

  detectCollision() {
    // detect collision with other tanks
    tanks.forEach((tank) => {
      if (tank !== this) {
        let dx = tank.x - this.x;
        let dy = tank.y - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy); // calculate distance
        if (distance < this.width / 2 + tank.width / 2) {
          // detect and resolve collision
          let overlap = (this.width / 2 + tank.width / 2) - distance;
          let angle = Math.atan2(dy, dx);
          let moveX = overlap * Math.cos(angle);
          let moveY = overlap * Math.sin(angle);

          this.x -= moveX / 2;
          this.y -= moveY / 2;
          tank.x += moveX / 2;
          tank.y += moveY / 2;
         }
      }
    });

    // detect collision with simple arena borders
    if (this.x - this.width / 2 < 0 ) {
      this.x = this.width / 2;
    } else if (this.x + this.width / 2 > canvas.width) {
      this.x = canvas.width - this.width / 2;
    }

    if (this.y - this.height / 2 < 0) {
      this.y = this.height / 2;
    } else if (this.y + this.height / 2 > canvas.height) {
      this.y = canvas.height - this.height / 2;
    }
  }

  checkHealth() {
    if(this.health <= 0){
      if(this.lives !== 0){
        this.lives -= 1;
        this.health = 100;
      }
      if(this.lives === 0){
        tanks.splice(tanks.indexOf(this), 1);
        if(this.player = "1"){
            winner = "1";
        } else {
            winner = "2";
        }
        delete this;
        gamestate = GAMESTATE.GAMEOVER;
      }
    }
  }

  reset() {
    this.lives = 3;
    this.accX = 0;
    this.accY = 0;
    if(tanks[0] === this){
      this.x = canvas.width * 0.25;
      this.y = canvas.height / 2;
    } else if(tanks[1] === this){
      this.x = canvas.width * 0.75;
      this.y = canvas.height / 2;
    }
  }
}

// define the Bullet class
class Bullet {
  constructor(x, y, angle, speed, damage, color, tank) {
    this.x = x;
    this.y = y;
    this.angle = angle + Math.PI * 0.5;
    this.speed = speed;
    this.damage = damage;
    this.color = color;
    this.tank = tank;
    this.radius = 5;
    this.dirChange = 0;
    this.dx = Math.cos(this.angle) * this.speed;
    this.dy = Math.sin(this.angle) * this.speed;
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    // ctx.rotate(this.angle);
    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
    ctx.fill();
    // ctx.rotate(-this.angle);
    ctx.closePath();
  }

  move() {
    if (allowableMove(forbiddenSpaces, this.x, this.y, this.dx, this.dy)[0] && allowableMove(forbiddenSpaces, this.x, this.y, this.dx, this.dy)[1]) {
      this.x += this.dx;
      this.y += this.dy;
    } else {
      bullets.splice(bullets.indexOf(this), 1); 
      delete this;
    }

    // detect collision with arena borders
    if (this.x + this.dx > canvas.width - this.radius|| this.x + this.dx < this.radius) {           //if colliding with edge of canvas, reflect
      if(this.angle === 2*Math.PI || this.angle === 3*Math.PI) {

      } else {
        this.dx = -this.dx;
        this.dirChange ++;
      }
    }
    if (this.y + this.dy < this.radius || this.y + this.dy > canvas.height - this.radius) {
      if(this.angle === 3*Math.PI/2 || this.angle === 5/2*Math.PI) {
        bullets.splice(bullets.indexOf(this), 1); 
        delete this;
      } else {
        this.dy = -this.dy;
        this.dirChange ++;
      }
    }
    if(this.dirChange > 1){
      bullets.splice(bullets.indexOf(this), 1);          
      delete this;                   //if 2nd bounce off wall, delete;
    }

    // detect collision with tanks
    tanks.forEach((tank) => {
      if (tank !== this.tank) {
        let dx = tank.x - this.x;
        let dy = tank.y - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < tank.width / 2 + this.radius) {
          bullets.splice(bullets.indexOf(this), 1);
          delete this;
          tank.health -= this.damage;
        }
      }
    });
  }
}

// open socket for players
// const socket = io("/webpage");

// listen for player data
// let I = 0
// socket.on("data", (data) => { // event name 
//   // update the players' tanks
//   // console.log(I);
//   // I++;
//   // console.log(`Player ${data.Player} data: ${data.x}, ${data.y}, ${data.Fire} Username: ${data.Username}`);

//   if (data.hasOwnProperty('x')){
//     tanks[parseInt(data.Player)-1].accX = -(data.x - 50)/250;
//   }
  
//   if (data.hasOwnProperty('y')){
//     tanks[parseInt(data.Player)-1].accY = (data.y - 50)/250;
//   }
  
//   if (data.hasOwnProperty('Fire')){
//     tanks[parseInt(data.Player)-1].fire = data.Fire;
//   }
    
// });

// define the game loop
let lastTime = 0;
// function gameLoop(timestamp) {
function gameLoop() {
  // console.log(gamestate);
  setTimeout(gameLoop, 0.5);
  if(enterPressed){
    start();
  }
  if(escPressed){
    togglePause();
  }
  if(qPressed){
    restart();
  }
  update();
  drawState();
  // let deltaTime = timestamp - lastTime;
  // lastTime = timestamp;
  // clear the canvas
  
  if(gamestate === GAMESTATE.RUNNING){
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    forbiddenSpaces.forEach((space) => {
      drawPoints(space[0], space[1], space[2], space[3]);
    });

    // update tanks
    tanks.forEach((tank) => {
      //tank.draw(); //moved the draw function into the move function
      tank.move();
      tank.checkHealth();
      tank.fireBullets();
      // socket.emit("clientData", {Player: tank.player, Lives: tank.lives.toString()});
    });

    // update bullets
    bullets.forEach((bullet) => {
      bullet.draw();
      bullet.move();
    });
    //more keys control stuff
    
    if(spacePressed){
      tanks[0].fire = '1';
    }
    else{
      tanks[0].fire = '0';
    }
    if(rightPressed) {
      tanks[0].accX = 1;
    }
    else if(leftPressed) {
      tanks[0].accX = -1;
    }
    else{
      tanks[0].accX = 0;
    }

    if(upPressed) {
      tanks[0].accY = -1;
    }
    else if(downPressed) {
      tanks[0].accY = 1;
    }
    else{
      tanks[0].accY = 0;
    }
  }
  // // request the next frame
  // requestAnimationFrame(gameLoop);
}

function start(){
    if  (gamestate !== GAMESTATE.MENU) return;
    if(tanks.length !== 2){
        for(let i=0; i<tanks.length; i++){
            tanks.splice(i, 1);
        }
        tanks.push(new Tank(canvas.width * 0.25, canvas.height / 2, 0, 0, "Red", "1", "0"));
        tanks.push(new Tank(canvas.width * 0.75, canvas.height / 2, 0, 0, "Blue", "2", "0"));
    } else {
        for(let i = 0; i < tanks.length; i++){
            tanks[i].reset(); 
        }
    }
    // ADD LEVEL STUFF ONCE DONE
    gamestate = GAMESTATE.RUNNING;
}

function restart(){
    if(tanks.length !== 2){
        for(let i=0; i<tanks.length; i++){
            tanks.splice(i, 1);
        }
        tanks.push(new Tank(canvas.width * 0.25, canvas.height / 2, 0, 0, "Red", "1", "0"));
        tanks.push(new Tank(canvas.width * 0.75, canvas.height / 2, 0, 0, "Blue", "2", "0"));
    } else {
        for(let i = 0; i < tanks.length; i++){
            tanks[i].reset(); 
        }
    }
    // ADD LEVEL STUFF ONCE DONE
    gamestate = GAMESTATE.MENU;
}

function update(){
  /* for(let i = 0; i < tanks.length; i++){
    if(tanks[i].lives === 0){
      gamestate = GAMESTATE.GAMEOVER;
    }
  } */

  if  (
        gamestate === GAMESTATE.PAUSED ||
        gamestate === GAMESTATE.MENU ||
        gamestate === GAMESTATE.GAMEOVER
      ) return;
}

function drawState(){
  if (gamestate === GAMESTATE.PAUSED) {
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "rgba(0,0,0,0.5";
    ctx.fill();

    ctx.font = "30px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText("Paused", canvas.width / 2, canvas.height / 2);
  }

  if (gamestate === GAMESTATE.MENU) {
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "rgba(0,0,0,0.1";
    ctx.fill();

    ctx.font = "30px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText(
        "Press ENTER To Start",
        canvas.width / 2,
        canvas.height / 2
    );
  }

  if (gamestate === GAMESTATE.GAMEOVER) {
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "rgba(0,0,0,0.1";
    ctx.fill();

    ctx.font = "30px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText("Player " + winner + " Wins", canvas.width / 2, canvas.height / 2);
    
    //added "game ending" server
    let winner = "";
      let looser = "";

      tanks.forEach((tank) => {
        if(tank.health === 0) {
          looser = tank.player;
        } else {
          winner = tank.player;
        }
        
      });
      socket.emit("game over", { player1: String(winner), player2: String(looser), winner: true });
      socket.on("history", (data) => {
        console.log(data);
      });
  }
}

function togglePause() {
    if (gamestate === GAMESTATE.PAUSED) {
      gamestate = GAMESTATE.RUNNING;
    } else {
      gamestate = GAMESTATE.PAUSED;
    }
}

// initialize the game
const GAMESTATE = {
    PAUSED: 0,
    RUNNING: 1,
    MENU: 2,
    GAMEOVER: 3
};

function init() {
  gamestate = GAMESTATE.MENU;
  document.body.appendChild(canvas);
  // create tanks
  // initialise tank positions to center and facing each other
  tanks.push(new Tank(canvas.width * 0.25, canvas.height / 2, 0, 0, "Red", "1", "0"));
  tanks.push(new Tank(canvas.width * 0.75, canvas.height / 2, 0, 0, "Blue", "2", "0"));

  forbiddenSpaces.forEach((space) => {
    drawPoints(space[0], space[1], space[2], space[3]);
  });

  // start the game loop
  gameLoop();
}

// run the game

init();

  </script>
</body>

</html>