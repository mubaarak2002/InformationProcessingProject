<html>
<!-- <head>
  <title>Brick Breaker</title>
	<meta charset="UTF-8" />
	<style>
		#gameScreen {
			border: 6px solid black;
		}
	</style>
</head> -->
<style>
  * {
    padding: 0;
    margin: 0;
  }
  canvas {
    background: rgb(181, 160, 56);
    display: block;
    margin: 0 auto;
  }
</style>

<body>
  <!-- <img id="tankImg" src="assets/tank.png"> -->

  <canvas id="canvas"></canvas>
  <script src="socket.io/socket.io.js"></script>
  <script>
    
    // define global variables

// create canvas
let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");

//key controls
let rightPressed = false; //movement
let leftPressed = false;
let upPressed = false;
let downPressed = false;
let commaPressed = false;
let periodPressed = false;
let spacePressed = false;

// height of window for reference 
canvas.height = window.innerHeight; //lock to 4:3 aspect ratio
canvas.width = canvas.height * 1.33;



// define arrays for tanks and bullets
let tanks = [];
let bullets = [];

//stuff for key controls. Comment out if not using
document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false);

function keyDownHandler(e) {
    if(e.key == "Right" || e.key == "ArrowRight") {
        rightPressed = true;
    }
    else if(e.key == "Left" || e.key == "ArrowLeft") {
        leftPressed = true;
    }
    if(e.key == "Up" || e.key == "ArrowUp") {
        upPressed = true;
    }
    else if(e.key == "down" || e.key == "ArrowDown") {
        downPressed = true;
    }
    if(e.keyCode == 188) {
        commaPressed = true;
    }
    else if(e.keyCode == 190) {
        periodPressed = true;
    }
    if(e.keyCode == 32) {
        spacePressed = true;
    }
}

function keyUpHandler(e) {
    if(e.key == "Right" || e.key == "ArrowRight") {
        rightPressed = false;
    }
    else if(e.key == "Left" || e.key == "ArrowLeft") {
        leftPressed = false;
    }
    if(e.key == "Up" || e.key == "ArrowUp") {
        upPressed = false;
    }
    else if(e.key == "down" || e.key == "ArrowDown") {
        downPressed = false;
    }
    if(e.keyCode == 188) {
        commaPressed = false;
    }
    else if(e.keyCode == 190) {
        periodPressed = false;
    }
    if(e.keyCode == 32) {
        spacePressed = false;
    }
}
// TODO: draw arena borders

// define the Tank class
class Tank {
  constructor(x, y, accX, accY, colour, player, fire) {
    this.x = x;
    this.y = y;
    this.accX = accX;
    this.accY = accY;
    this.colour = colour;
    this.width = 40;
    this.height = this.width;
    this.angle = 0;     //angle of movement
    this.shotAngle = 0; //angle of shooting
    this.magnitude = 0;
    this.speed = 5;
    this.health = 100;
    this.player = player;
    this.fire = fire;
    this.lives = 3;
  }

  draw() {
    ctx.save();  
    ctx.beginPath();
    this.angle = Math.atan2(this.accY, this.accX) + (Math.PI * 0.5);                     //tank object contains postion change info (here used to calculate direction of travel)
    ctx.save();
    //draw treads
    ctx.fillStyle = "Black";
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.fillRect(-25, -15, 50, 30);
    ctx.rotate(-this.angle);
    ctx.translate(-this.x, -this.y);
    ctx.closePath();

    ctx.beginPath();
    //draw body
    ctx.arc(this.x, this.y, 0.5 * this.width , 0, Math.PI * 2);      //tank object contains position info (tank.x and tank.y mark centre of tank circle)
    ctx.fillStyle = this.colour;                        //tank object contains colour
    ctx.fill();
    ctx.closePath();

    ctx.beginPath();

    this.shotAngle = this.angle + Math.PI; //comment out if you want turret rotating independently
    //draw barrel
    ctx.translate(this.x, this.y);
    ctx.rotate(this.shotAngle);           
    ctx.fillStyle = "Green"; 
    ctx.fillRect(-2, -2, 4, 35);
    ctx.rotate(-this.shotAngle);          
    ctx.translate(-this.x, -this.y);
    ctx.closePath();
    ctx.restore();
                        
  }


  move() {
    // Caculate angle and magnitude of movement based on the acceleration
    this.magnitude = Math.sqrt(this.accX * this.accX + this.accY * this.accY);
    this.angle = Math.atan2(this.accY, this.accX);

    // Update coordinates
    this.x += Math.cos(this.angle) * this.magnitude * this.speed;
    this.y += Math.sin(this.angle) * this.magnitude * this.speed;

    this.detectCollision();
  }

  fireBullets() {
    if (this.fire == "t") {
      // check of the tank is allowed to shoot
      const bullet = new Bullet(this.x, this.y, this.shotAngle, 10, 5, "black", this);
      bullets.push(bullet); // add the bullet to the bullets array
    }
  }

  detectCollision() {
    // detect collision with other tanks
    tanks.forEach((tank) => {
      if (tank !== this) {
        let dx = tank.x - this.x;
        let dy = tank.y - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy); // calculate distance
        if (distance < this.width / 2 + tank.width / 2) {
          // detect and resolve collision
          let overlap = (this.width / 2 + tank.width / 2) - distance;
          let angle = Math.atan2(dy, dx);
          let moveX = overlap * Math.cos(angle);
          let moveY = overlap * Math.sin(angle);
          this.x -= moveX / 2;
          this.y -= moveY / 2;
          tank.x += moveX / 2;
          tank.y += moveY / 2;
         }
      }
    });

    // detect collision with simple arena borders
    if (this.x - this.width / 2 < 0 ) {
      this.x = this.width / 2;
    } else if (this.x + this.width / 2 > canvas.width) {
      this.x = canvas.width - this.width / 2;
    }

    if (this.y - this.height / 2 < 0) {
      this.y = this.height / 2;
    } else if (this.y + this.height / 2 > canvas.height) {
      this.y = canvas.height - this.height / 2;
    }
  }

  checkHealth() {
    if(this.health <= 0){
      tanks.splice(tanks.indexOf(this), 1);
    }
  }
}

// define the Bullet class
class Bullet {
  constructor(x, y, angle, speed, damage, color, tank) {
    this.x = x;
    this.y = y;
    this.angle = angle + Math.PI * 0.5;
    this.speed = speed;
    this.damage = damage;
    this.color = color;
    this.tank = tank;
    this.radius = 5;
    this.dirChange = 0;
    this.dx = Math.cos(this.angle) * this.speed;
    this.dy = Math.sin(this.angle) * this.speed;
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    // ctx.rotate(this.angle);
    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
    ctx.fill();
    // ctx.rotate(-this.angle);
    ctx.closePath();
  }

  move() {
    this.x += this.dx;
    this.y += this.dy;
    // detect collision with arena borders
    if (this.x + this.dx > canvas.width - this.radius|| this.x + this.dx < this.radius) {           //if colliding with edge of canvas, reflect
      this.dx = -this.dx;
      this.dirChange ++;
    }
    if (this.y + this.dy < this.radius || this.y + this.dy > canvas.height - this.radius) {
      this.dy = -this.dy;
      this.dirChange ++;
    }
    if(this.dirChange > 1){
      bullets.splice(bullets.indexOf(this), 1);                             //if 2nd bounce off wall, delete;
    }

    // detect collision with tanks
    tanks.forEach((tank) => {
      if (tank !== this.tank) {
        let dx = tank.x - this.x;
        let dy = tank.y - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < tank.width / 2 + this.radius) {
          bullets.splice(bullets.indexOf(this), 1);
          tank.health -= this.damage;
        }
      }
    });
  }
}

// define the game loop
let lastTime = 0;
function gameLoop(timestamp) {
  let deltaTime = timestamp - lastTime;
  lastTime = timestamp;
  // clear the canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // listen for player data
  socket.on("data", (data) => { // event name 
    // update the players' tanks

    console.log("test");

    console.log(`Player ${data.Player} data: ${data.x}, ${data.y}, ${data.Fire}`);

    tanks[parseInt(data.Player)-1].accX = (data.x - 50)*2;
    tanks[parseInt(data.Player)-1].accY = (data.y - 50)*2;
    tanks[parseInt(data.Player)-1].fire = data.Fire;
  });

  // update tanks
  tanks.forEach((tank) => {
    tank.draw();
    tank.move();
    tank.checkHealth();
    tank.fireBullets();
    socket.emit("lives", {Player: tank.player, Lives: tank.lives.toString()});
  });

  // update bullets
  bullets.forEach((bullet) => {
    bullet.draw();
    bullet.move();
  });

  //more keys control stuff
  if(spacePressed){
    tanks[0].fire = 't';
  }
  else{
    tanks[0].fire = 'f';
  }
  if(rightPressed) {
    tanks[0].accX = 1;
  }
  else if(leftPressed) {
    tanks[0].accX = -1;
  }
  else{
    tanks[0].accX = 0;
  }

  if(upPressed) {
    tanks[0].accY = -1;
  }
  else if(downPressed) {
    tanks[0].accY = 1;
  }
  else{
    tanks[0].accY = 0;
  }

  // request the next frame
  requestAnimationFrame(gameLoop);
}

// initialize the game
function init() {
  document.body.appendChild(canvas);

  // create tanks
  // initialise tank positions to center and facing each other
  tanks.push(new Tank(canvas.width * 0.25, canvas.height / 2, 0, 0, "Red", "1", "f"));
  tanks.push(new Tank(canvas.width * 0.75, canvas.height / 2, 0, 0, "Blue", "2", "f"));

  // open socket for players
  socket = io("/webpage");

  // start the game loop
  gameLoop();
}

// run the game
init();
  </script>
</body>

</html>
