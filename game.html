<html>
<!-- <head>
  <title>Brick Breaker</title>
	<meta charset="UTF-8" />
	<style>
		#gameScreen {
			border: 6px solid black;
		}
	</style>
</head> -->
<style>
  * {
    padding: 0;
    margin: 0;
  }
  canvas {
    background: rgb(181, 160, 56);
    display: block;
    margin: 0 auto;
  }

</style>
<div id="container"></div>
<body>
  <!-- <img id="tankImg" src="assets/tank.png"> -->

<canvas id="canvas"></canvas>
<script src="/socket.io/socket.io.js"></script>
<script>
    
// define global variables

// create canvas
let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");

//key controls
let rightPressed = false; //movement
let leftPressed = false;
let upPressed = false;
let downPressed = false;
let commaPressed = false;
let periodPressed = false;
let spacePressed = false;
let escPressed = false;
let enterPressed = false;
let qPressed = false;
let winner = 0;
let gameOverSent = 0;

let maxLives = 5;

// function drawPoints(topLeft, topRight, bottomLeft, bottomRight) {
//   const canvas = document.getElementById("canvas");
//   const ctx = canvas.getContext("2d");
  
//   ctx.fillStyle = "black";
//   ctx.fillRect(topLeft[0], topLeft[1], -(topLeft[0] - topRight[0]), -(topLeft[1] - bottomLeft[1]));
// }

// function allowableMove(forbiddenSpaces, currentx, currenty, dx, dy) {
//   let legalXMove = true;
//   let legalYMove = true;
//   forbiddenSpaces.forEach(function check(space, index){
//       //given the lines are straight lines, a vertex will always define the maximum and minimum
//       //x and y values. This means that we can establish that the new y value cannot be inside
//       //the min/max y verticies if the new x value is also inside the min/max x verticies

//       let nx = currentx + dx
//       let ny = currenty + dy;
//       let minx = space[0][0];
//       let miny = space[0][1];
//       let maxx = space[1][0];
//       let maxy = space[1][1];

//       space.forEach(function thing(vertex, index) {
 
//         if (vertex[0] < minx) {
//           minx = vertex[0];
//         }
//         if (vertex[0] > maxx) {
//           maxx = vertex[0];
//         }
//         if (vertex[1] < miny) {
//           miny = vertex[1];
//         }
//         if (vertex[1] > maxy) {
//           maxy = vertex[1];
//         }
//       });
      
//       if (ny < maxy && ny > miny && nx < maxx && nx > minx) {
//         legalYMove = false;
//       }
//       if (nx < maxx && nx > minx && ny < maxy && ny > miny) {
//         legalXMove = false;
//       }
//     });
//   return[legalXMove, legalYMove];
// }
            

// height of window for reference 
if(window.innerHeight < window.innerWidth){
    canvas.height = window.innerHeight; //lock to 4:3 aspect ratio
    canvas.width = canvas.height * 1.33;
} else if (window.innerHeight >= window.innerWidth) {
    canvas.width = window.innerWidth; //lock to 4:3 aspect ratio
    canvas.height = canvas.width * 0.75;
}

let scalar = 0.001 * canvas.height;

//inside this should be rectangles with 4 points inside it to define a rectangle where you cannot
//enter, thus you can make them as big or as little as you want. but if you make them too small,
//and dx/dy is bigger than the width, you could jump through a square
//eg: const forbiddenSpaces = [ [[1,1], [2,2], [3,3], [4,4]] ] 
//change this to "const", not "let"
// let forbiddenSpaces = [];
//this is adding the wall boundaries to it:
//"+/- 2" is just to give the wall some non-zero thickness

//this is a square in the middle of edge length 50
//MUST BE OF THE FORMAT [ [top left], [top right], [bottom left], [bottom right] ]
// forbiddenSpaces = [ 
//                     [
//                        [canvas.width/2 - 50, canvas.height/2 - 50],
//                        [canvas.width/2 + 50, canvas.height/2 - 50],
//                        [canvas.width/2 - 50, canvas.height/2 + 50],
//                        [canvas.width/2 + 50, canvas.height/2 + 50]
//                     ]
//                   ];

// define arrays for tanks and bullets
let tanks = [];
//let tanksUsername = ["1", "2"];
const tanksUsername = new Map([
  ["player1user", "1"],
  ["player2user", "2"],
  ["player1state", "loser"],
  ["player2state", "loser"]
]);
let bullets = [];
let walls = [];
// TODO: draw arena borders
//stuff for key controls. Comment out if not using
document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false);

function keyDownHandler(e) {
    if(e.key == "Right" || e.key == "ArrowRight") {
        rightPressed = true;
    }
    else if(e.key == "Left" || e.key == "ArrowLeft") {
        leftPressed = true;
    }
    if(e.key == "Up" || e.key == "ArrowUp") {
        upPressed = true;
    }
    else if(e.key == "down" || e.key == "ArrowDown") {
        downPressed = true;
    }
    if(e.keyCode == 188) {
        commaPressed = true;
    }
    else if(e.keyCode == 190) {
        periodPressed = true;
    }
    else if(e.keyCode == 32) {
        spacePressed = true;
    }
    else if(e.keyCode == 27) {
        escPressed = true;
    }
    else if(e.keyCode == (13 || "Enter")) {
      // console.log("Enter pressed");
      enterPressed = true;
    }
    if(e.keyCode == 81) {
        qPressed = true;
    }
}

function keyUpHandler(e) {
    if(e.key == "Right" || e.key == "ArrowRight") {
        rightPressed = false;
    }
    else if(e.key == "Left" || e.key == "ArrowLeft") {
        leftPressed = false;
    }
    if(e.key == "Up" || e.key == "ArrowUp") {
        upPressed = false;
    }
    else if(e.key == "down" || e.key == "ArrowDown") {
        downPressed = false;
    }
    if(e.keyCode == 188) {
        commaPressed = false;
    }
    else if(e.keyCode == 190) {
        periodPressed = false;
    }
    else if(e.keyCode == 32) {
        spacePressed = false;
    }
    else if(e.keyCode == 27) {
        escPressed = false;
    }
    else if(e.keyCode == (13 || "Enter")) {
      // console.log("Enter pressed");
      enterPressed = false;
    }
    if(e.keyCode == 81) {
        qPressed = false;
    }
}

//define a small square wall block
class Wall {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.width = scalar*40;
    this.height = scalar*40;
  }
  draw() {
    ctx.beginPath();
    ctx.fillStyle = "Grey";
    ctx.fillRect(this.x, this.y, this.width, this.height);
    ctx.fillStyle = "Orange";
    ctx.fillRect(this.x + scalar*5, this.y + scalar*5, this.width - scalar*10, this.height - scalar*10);
    ctx.closePath();
  }
}

// define the Tank class
class Tank {
  constructor(x, y, accX, accY, colour, player, username, fire) {
    this.x = x;
    this.y = y;
    this.accX = accX*scalar;
    this.accY = accY*scalar;
    this.colour = colour;
    this.width = 40*scalar;
    this.height = this.width;
    this.angle = 0;     //angle of movement
    this.shotAngle = 0; //angle of shooting
    this.magnitude = 0;
    this.speed = 2*scalar;
    this.health = 100;
    this.player = player;
    this.username = username;
    this.fire = fire;
    // this.previousFire = "0";
    this.fireable = 1;
    this.lives = maxLives;
    this.previousLives = maxLives + 1;
  }

  draw() {
    // ctx.save();  
    ctx.beginPath();
    this.angle = Math.atan2(this.accY, this.accX) + (Math.PI * 0.5);                     //tank object contains postion change info (here used to calculate direction of travel)
    // ctx.save();
    //draw treads
    ctx.fillStyle = "Black";
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.fillRect(-0.625*this.width, -0.375*this.width, 1.25*this.width, 0.75*this.width);
    ctx.rotate(-this.angle);
    ctx.translate(-this.x, -this.y);
    ctx.closePath();

    ctx.beginPath();
    //draw body
    ctx.arc(this.x, this.y, 0.5 * this.width , 0, Math.PI * 2);      //tank object contains position info (tank.x and tank.y mark centre of tank circle)
    ctx.fillStyle = this.colour;                        //tank object contains colour
    ctx.fill();
    ctx.closePath();

    ctx.beginPath();

    this.shotAngle = this.angle + Math.PI; //comment out if you want turret rotating independently
    //draw barrel
    ctx.translate(this.x, this.y);
    ctx.rotate(this.shotAngle);           
    ctx.fillStyle = "Green"; 
    ctx.fillRect(-0.05*this.width, -0.05*this.width, 0.1*this.width, this.width);
    ctx.rotate(-this.shotAngle);          
    ctx.translate(-this.x, -this.y);
    ctx.closePath();
    // ctx.restore();
                        
  }

  move() {
    // Caculate angle and magnitude of movement based on the acceleration
    this.magnitude = Math.sqrt(this.accX * this.accX + this.accY * this.accY);
    this.angle = Math.atan2(this.accY, this.accX);

    // // Limit magnitude
    // if (this.magnitude >= 141) {
    //   this.magnitude = 141;
    // } else if (this.magnitude >= 100) {
    //   this.magnitude = 100;
    // } else if (this.magnitude >= 75) {
    //   this.magnitude = 75;
    // } else if (this.magnitude >= 50) {
    //   this.magnitude = 50;
    // } else if (this.magnitude >= 25) {
    //   this.magnitude = 25;
    // } else {
    //   this.magnitude = 0;
    // }

    // Update coordinates
    let nx = Math.cos(this.angle) * this.magnitude * this.speed;
    let ny = Math.sin(this.angle) * this.magnitude * this.speed;
    
    this.x += nx;
    this.y += ny;

    // if (allowableMove(forbiddenSpaces, this.x, this.y, nx, ny)[0]) {

    //   this.x += nx;
    // }
    // if (allowableMove(forbiddenSpaces, this.x, this.y, nx, ny)[1]) {

    //   this.y += ny;
    // }
    this.detectCollision(nx, ny);
    this.draw();
  }

  fireBullets() {
    if (this.fire == "1") {
      // check of the tank is allowed to shoot
      const bullet = new Bullet(this.x, this.y, this.shotAngle, 10, 100, "black", this);
      bullets.push(bullet); // add the bullet to the bullets array

      this.fire = "0";
      this.fireable = 0;
    }
  }

  detectCollision(nx, ny) {
    // detect collision with other tanks
    tanks.forEach((tank) => {
      if (tank !== this) {
        let dx = tank.x - this.x;
        let dy = tank.y - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy); // calculate distance
        if (distance < this.width / 2 + tank.width / 2) {
          // detect and resolve collision
          let overlap = (this.width / 2 + tank.width / 2) - distance;
          let angle = Math.atan2(dy, dx);
          let moveX = overlap * Math.cos(angle);
          let moveY = overlap * Math.sin(angle);

          this.x -= moveX / 2;
          this.y -= moveY / 2;
          tank.x += moveX / 2;
          tank.y += moveY / 2;
         }
      }

    });
    //detect collision with walls
    walls.forEach((wall) => {
      //this is slightly funky, since collision detection is being called after the tank has moved
      //so we're calling it on the current x, rather than x + dx (detect a collision after it has already occurred)
        if (this.x + this.width/2 > wall.x &&
            this.x - this.width/2 < (wall.x + wall.width) &&
            this.y + this.width/2 > wall.y &&
            this.y - this.width/2 < (wall.y + wall.height)) {
              //console.log("collision");
              this.x -= nx;
              this.y -= ny;
            }
    });

    // detect collision with simple arena borders
    if (this.x - this.width / 2 < 0 ) {
      this.x = this.width / 2;
    } else if (this.x + this.width / 2 > canvas.width) {
      this.x = canvas.width - this.width / 2;
    }

    if (this.y - this.height / 2 < 0) {
      this.y = this.height / 2;
    } else if (this.y + this.height / 2 > canvas.height) {
      this.y = canvas.height - this.height / 2;
    }
  }

  checkHealth() {
    if(this.health <= 0){
      if(this.lives !== 0){
        this.lives -= 1;
        this.health = 100;
      }
      if(this.lives === 0){
        tanks.splice(tanks.indexOf(this), 1);
        if(this.player = "1"){
            winner = 1;
        } else {
            winner = 2;
        }
        delete this;
        gamestate = GAMESTATE.GAMEOVER;
      }
    }
  }

  reset() {
    this.lives = 3;
    this.accX = 0;
    this.accY = 0;
    if(tanks[0] === this){
      this.x = canvas.width * 0.25;
      this.y = canvas.height / 2;
    } else if(tanks[1] === this){
      this.x = canvas.width * 0.75;
      this.y = canvas.height / 2;
    }
  }
}

// define the Bullet class
class Bullet {
  constructor(x, y, angle, speed, damage, color, tank) {
    this.x = x;
    this.y = y;
    this.angle = angle + Math.PI * 0.5;
    this.speed = speed*scalar;
    this.damage = damage;
    this.color = color;
    this.tank = tank;
    this.radius = 5*scalar;
    this.dirChange = 0;
    this.dx = Math.cos(this.angle) * this.speed;
    this.dy = Math.sin(this.angle) * this.speed;
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    // ctx.rotate(this.angle);
    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
    ctx.fill();
    // ctx.rotate(-this.angle);
    ctx.closePath();
  }

  move() {
    // if (allowableMove(forbiddenSpaces, this.x, this.y, this.dx, this.dy)[0] && allowableMove(forbiddenSpaces, this.x, this.y, this.dx, this.dy)[1]) {
      this.x += this.dx;
      this.y += this.dy;
    // } else {
    //   bullets.splice(bullets.indexOf(this), 1); 
    //   delete this;
    // }

    // detect collision with arena borders
    if (this.x + this.dx > canvas.width - this.radius|| this.x + this.dx < this.radius) {           //if colliding with edge of canvas, reflect
      if(this.angle === 2*Math.PI || this.angle === 3*Math.PI) {
        bullets.splice(bullets.indexOf(this), 1);
        delete this;
      } else {
        this.dx = -this.dx;
        this.dirChange ++;
      }
    }
    if (this.y + this.dy < this.radius || this.y + this.dy > canvas.height - this.radius) {
      if(this.angle === 3*Math.PI/2 || this.angle === 5/2*Math.PI) {
        bullets.splice(bullets.indexOf(this), 1); 
        delete this;
      } else {
        this.dy = -this.dy;
        this.dirChange ++;
      }
    }
    if(this.dirChange > 2){
      bullets.splice(bullets.indexOf(this), 1);          
      delete this;                   //if 2nd bounce off wall, delete;
    }

    // detect collision with tanks
    tanks.forEach((tank) => {
      if (tank !== this.tank) {
        let dx = tank.x - this.x;
        let dy = tank.y - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < tank.width / 2 + this.radius) {
          bullets.splice(bullets.indexOf(this), 1);
          delete this;
          tank.health -= this.damage;
        }
      }
    });
    //detect collision with walls
    walls.forEach((wall) => {
      //this is slightly funky, since collision detection is being called after the tank has moved
      //so we're calling it on the current x, rather than x + dx (detect a collision after it has already occurred)
      if (this.x + this.radius > wall.x && 
            this.x - this.radius < (wall.x + wall.width) &&
            this.y + this.radius > wall.y &&
            this.y - this.radius < (wall.y + wall.height)) {

              this.x -= this.dx;
              this.y -= this.dy;
              //to calc angle of bullet reflection, find which direction bullet is coming into wall

              if(this.x >= wall.x + wall.width || this.x <= wall.x){
                //console.log("bounce dx");
                this.dx = -this.dx;
                this.dirChange++;
              }
              else if(this.y >= wall.y + wall.height || this.y <= wall.y){
                //console.log("bounce dy");
                this.dy = -this.dy;
                this.dirChange++;
              }
              else{
                bullets.splice(bullets.indexOf(this), 1);
                delete this;
              }
            }
    });
  }
}

//builds walls in an L shape
function wallsL(x, y, breadth, length, angle, reverse){
                //x/y give location,
                //width/height give shape dimensions (in blocks),
                //angle rotates shape
                //flipV and flipH flip vertically and horizontally
      for(let i = 0; i <= breadth; i++){
          walls.push(new Wall(x + i*scalar*40, y));
      }
      for(let j = 0; j <= length; j++){
          walls.push(new Wall(x + breadth*scalar*40, y + j*scalar*40));
      }
}

function wallsLine(x, y, length, rotate){
  //if rotate = true, rotate 90 degrees
  if(!rotate){
    for(let i = 0; i <= length; i++){
            walls.push(new Wall(x + i*scalar*40, y));
    }
  }
  else if(rotate){
    for(let i = 0; i <= length; i++){
            walls.push(new Wall(x, y + i*scalar*40));
    }
  }
}

// // open socket for players
const socket = io("/webpage");

socket.on("history", (data) => {
  console.log(data);
});

// // listen for player data
// // let I = 0
socket.on("data", (data) => { // event name 
  // update the players' tanks
  // console.log(I);
  // I++;
  // console.log(`Player ${data.Player} data: ${data.x}, ${data.y}, ${data.Fire} Username: ${data.Username}`);

    if (data.hasOwnProperty('x')){
      tanks[parseInt(data.Player)-1].accX = -(data.x - 50)/250;
    }

    if (data.hasOwnProperty('y')){
      tanks[parseInt(data.Player)-1].accY = (data.y - 50)/250;
    }
  
    if (data.hasOwnProperty('Fire')){
        // console.log(tanks[parseInt(data.Player)-1].previousFire, "  ", data.Fire);
        if (data.Fire == "1" && tanks[parseInt(data.Player)-1].fireable == 1) {
          tanks[parseInt(data.Player)-1].fire = "1";
        }

        if (data.Fire == "0") {
          tanks[parseInt(data.Player)-1].fireable = 1;
        }

        // if(tanks[parseInt(data.Player)-1].previousFire == "0" && data.Fire == "1"){
        //     tanks[parseInt(data.Player)-1].fire = data.Fire;
        //     tanks[parseInt(data.Player)-1].previousFire = "1";
        // } else if(tanks[parseInt(data.Player)-1].previousFire == "1" && data.Fire == "1") {
        //     tanks[parseInt(data.Player)-1].fire = "0";
        // } else {
        //     tanks[parseInt(data.Player)-1].fire = "0";
        //     tanks[parseInt(data.Player)-1].previousFire = "0";
        // }
    }
    

    if (data.hasOwnProperty('Username')){
        if(parseInt(data.Player) === 1){
            tanksUsername["player1user"] = data.username;
        } else if (parseInt(data.Player) === 2) {
            tanksUsername["player2user"] = data.username;
        }
    }
    
});

//these are the players in the current session, so there should only
//be two entries in this array
let current_session_players = [];

// define the game loop
let lastTime = 0;
// function gameLoop(timestamp) {
function gameLoop() {
  // console.log(gamestate);
  setTimeout(gameLoop, 0.5);
  //console.log(tanks);
  
  if(current_session_players.length === 0) {
    gamestate = GAMESTATE.TWOPLAYERWAITING;
  } else if (current_session_players.length === 1) {
    gamestate = GAMESTATE.ONEPLAYERWAITING;
  } else if (current_session_players.length === 2 && gamestate === GAMESTATE.ONEPLAYERWAITING) {
    gamestate = GAMESTATE.MENU;
  }

  if(enterPressed && gamestate === GAMESTATE.MENU){
    start();
  }
  if(escPressed){
    togglePause();
  }
  if(qPressed){
    restart();
  }
  update();
  drawState();
  // let deltaTime = timestamp - lastTime;
  // lastTime = timestamp;
  // clear the canvas
  
  if(gamestate === GAMESTATE.RUNNING){
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // forbiddenSpaces.forEach((space) => {
    //   drawPoints(space[0], space[1], space[2], space[3]);
    // });

    // update tanks
    tanks.forEach((tank) => {
        //tank.draw(); //moved the draw function into the move function
        tank.move();
        tank.checkHealth();
        tank.fireBullets();
        // socket.emit("clientData", {Player: tank.player, Lives: tank.lives.toString()});
        if (tank.lives != tank.previousLives) {
            livesSend = tank.lives.toString() + "f";
            socket.emit("clientData", {Player: tank.player, Lives: livesSend});
            tank.previousLives = tank.lives;
        }
    });
    walls.forEach((wall) => {
        wall.draw();
    });

    // update bullets
    bullets.forEach((bullet) => {
      bullet.draw();
      bullet.move();
    });
    //more keys control stuff

    
    if(spacePressed){
      tanks[0].fire = '1';
    }
    else{
      tanks[0].fire = '0';
    }
    if(rightPressed) {
      tanks[0].accX = 1;
    }
    else if(leftPressed) {
      tanks[0].accX = -1;
    }
    else{
      tanks[0].accX = 0;
    }

    if(upPressed) {
      tanks[0].accY = -1;
    }
    else if(downPressed) {
      tanks[0].accY = 1;
    }
    else{
      tanks[0].accY = 0;
    }
  }
  // // request the next frame
  // requestAnimationFrame(gameLoop);
}

function start(){
    if  (gamestate !== GAMESTATE.MENU) return;
    if(tanks.length !== 2){
        for(let i=0; i<tanks.length; i++){
            tanks.splice(i, 1);
        }
        //added the players in the current session to the tanks
        tanks.push(new Tank(canvas.width * 0.25, canvas.height / 2, 0, 0, current_session_players[0], "1", "0"));
        tanks.push(new Tank(canvas.width * 0.75, canvas.height / 2, 0, 0, current_session_players[1], "2", "0"));
        wallsL(canvas.width/2, canvas.height/2, 3, 4, 0, 1);
    } else {
        for(let i = 0; i < tanks.length; i++){
            tanks[i].reset(); 
        }
    }
    // ADD LEVEL STUFF ONCE DONE
    gamestate = GAMESTATE.RUNNING;
}

function restart(){
    if(tanks.length !== 2){
        for(let i=0; i<tanks.length; i++){
            tanks.splice(i, 1);
        }
        tanks.push(new Tank(canvas.width * 0.25, canvas.height / 2, 0, 0, "Red", "1", "0"));
        tanks.push(new Tank(canvas.width * 0.75, canvas.height / 2, 0, 0, "Blue", "2", "0"));
        wallsL(canvas.width/2, canvas.height/2, 3, 4, 0, 1);
    } else {
        for(let i = 0; i < tanks.length; i++){
            tanks[i].reset(); 
        }
    }
    // ADD LEVEL STUFF ONCE DONE
    gamestate = GAMESTATE.MENU;
}

function update(){
  /* for(let i = 0; i < tanks.length; i++){
    if(tanks[i].lives === 0){
      gamestate = GAMESTATE.GAMEOVER;
    }
  } */

  if  (
        gamestate === GAMESTATE.PAUSED ||
        gamestate === GAMESTATE.MENU ||
        gamestate === GAMESTATE.GAMEOVER
      ) return;
}

function drawState(){

  let fontSize = 30*scalar;

  if (gamestate === GAMESTATE.PAUSED) {
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "rgba(0,0,0,0.5";
    ctx.fill();

    ctx.font = (fontSize|0) + "px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText("Paused", canvas.width / 2, canvas.height / 2);
  }

  if (gamestate === GAMESTATE.MENU) {
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "rgba(0,0,0,0.1";
    ctx.fill();

    ctx.font = (fontSize|0) + "px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText(
        "Press ENTER To Start",
        canvas.width / 2,
        canvas.height / 2
    );
  }

  //added the Gamestate for Waiting for __ players:

  if (gamestate === GAMESTATE.TWOPLAYERWAITING) {
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "rgba(0,0,0,0.1";
    ctx.fill();

    ctx.font = (fontSize|0) + "px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText(
        "Waiting for Two Players",
        canvas.width / 2,
        canvas.height / 2
    );
  }

  if (gamestate === GAMESTATE.ONEPLAYERWAITING) {
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "rgba(0,0,0,0.1";
    ctx.fill();

    ctx.font = (fontSize|0) + "px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText(
        "Waiting for One Player",
        canvas.width / 2,
        canvas.height / 2
    );
  }


//END OF OMAR'S ADDITIONS (SUN 18 MARCH)


  if (gamestate === GAMESTATE.GAMEOVER) {
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "rgba(0,0,0,0.1";
    ctx.fill();

    ctx.font = (fontSize|0) + "px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText("Player " + winner.toString() + " Wins", canvas.width / 2, canvas.height / 2);


    let player1user = tanksUsername["player1user"];
    let player2user = tanksUsername["player2user"];
    if(!gameOverSent) {
      if(winner === 2 ){
          tanksUsername["player1state"] = "loser";
          tanksUsername["player2state"] = "winner";
          if(tanksUsername["player2user"] > tanksUsername["player1user"]){
              socket.emit("game over", {player1user: "Winner", player2user: "Loser"});
          } else {
              socket.emit("game over", {player2user: "Loser", player1user: "Winner"});
          }
          gameOverSent=1;
      } else {
          tanksUsername["player2state"] = "loser";
          tanksUsername["player1state"] = "winner";
          if(tanksUsername["player2user"] > tanksUsername["player1user"]){
              socket.emit("game over", {player1user: "Loser", player2user: "Winner"});
          } else {
              socket.emit("game over", {player2user: "Winner", player1user: "Loser"});
          }
          gameOverSent=1;
      }
    }
    
  }
}

function togglePause() {
    if (gamestate === GAMESTATE.PAUSED) {
      gamestate = GAMESTATE.RUNNING;
    } else if (gamestate === GAMESTATE.RUNNING) {
      gamestate = GAMESTATE.PAUSED;
    }
}

// initialize the game
const GAMESTATE = {
    PAUSED: 0,
    RUNNING: 1,
    MENU: 2,
    GAMEOVER: 3,
    TWOPLAYERWAITING: 4,
    ONEPLAYERWAITING: 5
};

function init() {
  //gamestate = GAMESTATE.TWOPLAYERWAITING;
  gamestate = GAMESTATE.MENU;
  document.body.appendChild(canvas);
  // create tanks
  // initialise tank positions to center and facing each other
   //tanks.push(new Tank(canvas.width * 0.25, canvas.height / 2, 0, 0, "Red", "1", "0"));
//   tanks.push(new Tank(canvas.width * 0.75, canvas.height / 2, 0, 0, "Blue", "2", "0"));
  
  //USE TO DEBUG STUFF:
  current_session_players[0] = "JJ"
  current_session_players[1] = "RORY"

  
//   forbiddenSpaces.forEach((space) => {
//     drawPoints(space[0], space[1], space[2], space[3]);
//   });

  // start the game loop
  gameLoop();
}

// run the game

init();

</script>
</body>

</html>
