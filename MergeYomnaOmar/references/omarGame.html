<!--this is the example script i was running to see how the js code worked 
    it is kinda a mess but it does run (I think)-->



    <!DOCTYPE html>
    <html lang="en-US">
      <head>
        <meta charset="utf-8" />
        <title>Gamedev Canvas Workshop</title>
        <style>
          * {
            padding: 0;
            margin: 0;
          }
          canvas {
            background: #5ee;
            display: block;
            margin: 0 auto;
          }
        </style>
      </head>
      <body>
        <canvas id="myCanvas" width="480" height="320"></canvas>
      </body>
    
      
      <script src="/socket.io/socket.io.js"></script>
      <script>
        // JavaScript code goes here
        const canvas = document.getElementById("myCanvas");
        const ctx = canvas.getContext("2d");
        let x = canvas.width / 2;
        let y = canvas.height - 30;
    
        let dx = 0.2;
        let dy = -0.2;
        const ballRadius = 10;
        const paddleHeight = 10;
        const paddleWidth = 75;
        let paddleX = (canvas.width - paddleWidth) / 2;
        let rightPressed = false;
        let leftPressed = false;
        const brickRowCount = 3;
        const brickColumnCount = 5;
        const brickWidth = 75;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = 30;
        const brickOffsetLeft = 30;
        let shotAngle = 1;
    
        let WkeyDown = false;
        let SkeyDown = false;
        let AkeyDown = false;
        let DkeyDown = false;
        let SpaceBarDown = false;
    
        let WkeyDown2 = false;
        let SkeyDown2 = false;
        let AkeyDown2 = false;
        let DkeyDown2 = false;
        let CtrlKeyDown2 = false;
    
        let QKeyDown = false;
        let EKeyDown = false;
        let LeftVdown = false;
        let rightVdown = false;
    
        const socket = io();
    
        //inside this should be rectangles with 4 points inside it to define a rectangle where you cannot
        //enter, thus you can make them as big or as little as you want. but if you make them too small,
        //and dx/dy is bigger than the width, you could jump through a square
        //eg: const forbiddenSpaces = [ [[1,1], [2,2], [3,3], [4,4]] ] 
        //change this to "const", not "let"
        let forbiddenSpaces = [];
        //this is adding the wall boundaries to it:
        //"+/- 2" is just to give the wall some non-zero thickness
        forbiddenSpaces = [ [[0,0], [0, canvas.height + 2], [-2, 0], [-10, canvas.height + 2]],                                                 // left side
                            [[canvas.width, 0], [canvas.width + 2, 0], [canvas.width, canvas.height + 2], [canvas.width + 2, canvas.height]],   // right side
                            [[0,0], [0,-2], [canvas.width + 2, 0], [canvas.width + 2, -2]],                                                     // top
                            [[canvas.width, canvas.height], [canvas.width, canvas.height + 2], [0, canvas.height], [0, canvas.height + 2]],     // bottom
                          ];
    
        // define arrays for tanks and bullets
        let tanks = [];
        let bullets = [];
          
        // add event listeners for keyboard input
        let keys = {};
    
        document.addEventListener("keydown", (event) => {
          keys[event.code] = true;
        });
    
        class Tank {
          constructor(x, y, player, angle, theta, fire, health, mode) {
            this.x = x;
            this.y = y;
            //angle is the angle of the turret
            this.angle = angle;
            this.player = player;
            this.theta = theta;
            this.health = health;
            this.fire = fire;
            this.mode = mode;
            this.width = 40;
            this.draw();
          }
    
          fireBullets() {
    
            //currently using SpaceBarDown, find a way to fix
            //if (this.fire == true) {  
            if (SpaceBarDown == true && this.mode === 1) {
              console.log("pew")
              // check of the tank is allowed to shoot
              const bullet = new Bullet(this.x, this.y, this.angle + Math.PI/2, 10, 1, "black");
              bullets.push(bullet); // add the bullet to the bullets array
              //reset the fire variable
              this.fire = false;
              SpaceBarDown = false;
            } else if (CtrlKeyDown2 == true && this.mode === 2){
                console.log("pew")
                // check of the tank is allowed to shoot
                const bullet = new Bullet(this.x, this.y, this.angle + Math.PI/2, 10, 1, "black");
                bullets.push(bullet); // add the bullet to the bullets array
                //reset the fire variable
                this.fire = false;
                CtrlKeyDown2 = false;
            }
            
          }
    
          draw() {
            ctx.save();
            ctx.beginPath();
    
            //draw treads
            ctx.fillStyle = "Black";
            ctx.translate(this.x, this.y);
            ctx.rotate(this.theta);
            ctx.fillRect(-25, -15, 50, 30);
            ctx.rotate(-this.theta);
            ctx.translate(-this.x, -this.y);
            ctx.closePath();
    
            //ROTATION TO FACE DIRECTION:
            //theta is the angle of the black squares around the red dot, meaning these face in the direction
            //of movement. the turret angle is this.angle, and is simply being forced to face in the direction
            //of travel, change this.angle to change the angle
    
            //this is handled in the move function
    
    
            ctx.beginPath();
            //draw body
            ctx.arc(this.x, this.y, 20 , 0, Math.PI * 2);      //tank object contains position info (tank.x and tank.y mark centre of tank circle)
            ctx.fillStyle = "Red";                        //tank object contains colour
            ctx.fill();
            ctx.closePath();
    
            ctx.beginPath();
            //draw barrel
            //ctx.arc(x, y, 25, 0, ((shotAngle * 0.05) % (Math.PI * 2))); //tank object contains shotAngle, which specifies direction of barrel/shooting
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.fillStyle = "Green"; 
            ctx.fillRect(-2, -2, 4, 35);
            //ctx.rotate(-);
            //ctx.translate(-x, -y);                                        //draw line from end of barrel to centre of tank
                                                          //shotAngle should be controlled by tilting the nios2
            ctx.rotate(-this.angle);
            ctx.translate(-this.x, -this.y);
            ctx.closePath();
    
          }
    
          move () {
            let word = "NONE";
            if (this.mode === 1) {
              
              if (QKeyDown) {
              
                this.angle += 0.1;
    
              }if (EKeyDown) {
    
                this.angle -= 0.1;
    
              } if (WkeyDown) {
    
                word = "UP";
    
              }if (SkeyDown) {
            
                word = "DOWN";
    
              }if (AkeyDown) {
    
                word = "LEFT";
    
              }if (DkeyDown) {
    
                word = "RIGHT";
            
              }
            } else {
              if (LeftVdown) {
                
                this.angle += 0.1;
    
              }if (rightVdown) {
    
                this.angle -= 0.1;
    
              }
              if (WkeyDown2) {
    
                word = "UP";
    
              }if (SkeyDown2) {
            
                word = "DOWN";
    
              }if (AkeyDown2) {
    
                word = "LEFT";
    
              }if (DkeyDown2) {
    
                word = "RIGHT";
            
              }
            }
    
            //eg: const forbiddenSpaces = [ [[1,1], [2,2], [3,3], [4,4]] ]
          
            //the n prefix stands for "new"
            //console.log("updating postioning (" + this.x + ", " + this.y + ")");
    
            let nx = this.x;
            let ny = this.y;
            if (word === "UP") {
              ny += dy;
              //this.angle = Math.PI;
              this.theta = -Math.PI;
            }
            if (word === "DOWN") {
              ny -= dy;
              //this.angle = 0;
              this.theta = 0;
            }
            if (word === "LEFT") {
              nx -= dx;
             // this.angle = Math.PI/2;
              this.theta = Math.PI/2;
            }
            if (word === "RIGHT") {
              nx += dx;
              //this.angle = -Math.PI/2;
              this.theta = -Math.PI/2;
            }
            let illigalYmove = false;
            let illigalXmove = false;
            forbiddenSpaces.forEach(function check(space, index){
              //given the lines are straight lines, a vertex will always define the maximum and minimum
              //x and y values. This means that we can establish that the new y value cannot be inside
              //the min/max y verticies if the new x value is also inside the min/max x verticies
              
              let minx = space[0][0];
              let miny = space[0][1];
              let maxx = space[1][0];
              let maxy = space[1][1];
    
              space.forEach(function thing(vertex, index) {
                //console.log("scanningSpaces")
                if (vertex[0] < minx) {
                  minx = vertex[0];
                }
                if (vertex[0] > maxx) {
                  maxx = vertex[0];
                }
                if (vertex[1] < miny) {
                  miny = vertex[1];
                }
                if (vertex[1] > maxy) {
                  maxy = vertex[1];
                }
              });
              
              if (ny < maxy && ny > miny && nx < maxx && nx > minx) {
                //console.log("Is illigal With: nx: " + nx + " ny: " + ny + " maxx: " + maxx + " maxy: " + maxy + " minx: " + minx + " miny: " + miny);
                illigalYmove = true;
              }
              if (nx < maxx && nx > minx && ny < maxy && ny > miny) {
                //console.log("Is illigal With: nx: " + nx + " ny: " + ny + " maxx: " + maxx + " maxy: " + maxy + " minx: " + minx + " miny: " + miny);
                illigalXmove = true
              } else {
                //console.log("valid move");
              }
    
    
          });
            //console.log(newPos);
            //console.log("illigalXMove: " + illigalXmove + " illigalYmove: " + illigalYmove);
            if (!illigalXmove) {
              
              this.x = nx
            }
            if (!illigalYmove){
              //console.log(":(");
              this.y = ny
            }
            this.detectCollision();
          }
          
          detectCollision() {
            // detect collision with other tanks
            tanks.forEach((tank) => {
              if (tank !== this) {
                //need to redevine "this"
                let dx = tank.x - this.x;
                let dy = tank.y - this.y;
                let distance = Math.sqrt(dx * dx + dy * dy); // calculate distance
                //console.log("dy: " + dy + " dx: " + dx);
                if (distance < this.width / 2 + 10 / 2) {
    
                  //console.log("collision: " + distance);
                  // detect and resolve collision
                  let overlap = (this.width / 2 + tank.width / 2) - distance;
                  //let overlap = (10 / 2 + 10 / 2) - distance;
                  let angle = Math.atan2(dy, dx);
                  let moveX = overlap * Math.cos(angle);
                  let moveY = overlap * Math.sin(angle);
                  this.x -= moveX / 2;
                  this.y -= moveY / 2;
                  tank.x += moveX / 2;
                  tank.y += moveY / 2;
                }
              }
            });
          }
    
        }
        
        
    
        // define the Bullet class
        class Bullet {
          constructor(x, y, angle, speed, damage, color) {
            this.x = x;
            this.y = y;
            this.angle = angle;
            this.speed = speed;
            this.damage = damage;
            this.color = color;
            this.radius = 5;
            this.draw()
          }
    
          draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.save();
          }
    
          move() {
            let dx = Math.cos(this.angle) * this.speed;
            let dy = Math.sin(this.angle) * this.speed;
            this.x += dx;
            this.y += dy;
            // detect collision with arena borders
            if (
              this.x - this.radius < 0 ||
              this.x + this.radius > canvas.width ||
              this.y - this.radius < 0 ||
              this.y + this.radius > canvas.height
            ) {
              bullets.splice(bullets.indexOf(this), 1);
            }
    
            // detect collision with tanks
            tanks.forEach((tank) => {
              //changing to a constant, currently "tank" has no property width
              let dx = tank.x - this.x;
              let dy = tank.y - this.y;
              let distance = Math.sqrt(dx * dx + dy * dy);
              //if (distance < tank.width / 2 + this.radius) {
                if (distance < 10) {
                console.log("hit")
                bullets.splice(bullets.indexOf(this), 1);
                tank.health -= this.damage;
                tanks.forEach((tank) => {
                    console.log("health: " + tank.health);
    
                });
              }
            });
          }
        }
        
        
        function updateBoard() {
    
          while(1) {
    
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // update tanks
            tanks.forEach((tank) => {
              //FIX: Dont need to keep redrawing tank
              tank.move();
              tank.draw();
              tank.fireBullets();
              });
            bullets.forEach((bullet) => {
              bullet.move();
              bullet.draw();
            });
            
            socket.on("data", (data) => { // event name 
            // update the players' tanks
              var decodedData = JSON.parse(data);
    
              console.log(`Player ${decodedData.Player} data: ${decodedData.x}, ${decodedData.y}, ${decodedData.Fire}`);
    
              tanks[parseInt(decodedData.Player)-1].accX = decodedData.x;
              tanks[parseInt(decodedData.Player)-1].accY = decodedData.y;
              tanks[parseInt(decodedData.Player)-1].fire = decodedData.Fire;
            });
    
          }
    
        }
        
    
        //how to find the keys: https://developer.mozilla.org/en-US/docs/Web/API/Element/keyup_event
    
        //couldnt find the key for wsad, thus the movement is currently mapped
        //to the arrow keys, need to change to other keys
        /* document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);
        function keyDownHandler(e) {
          if (e.key === "Right" || e.key === "ArrowRight") {
            //rightPressed = true;
            DkeyDown = true;
          }
          if (e.key === "Left" || e.key === "ArrowLeft") {
            //leftPressed = true;
            AkeyDown = true;
          }
          if (e.key === "Up" || e.key === "ArrowUp") {
            WkeyDown = true;
          }
          if (e.key === "Down" || e.key === "ArrowDown") {
            SkeyDown = true;
    
            //moved here because isn't working with spacebar
            
            //SpaceBarDown = true;
          
          } 
          if (e.key === "Space" || e.key === "ShiftLeft") {
            //console.log("space")
            SpaceBarDown = true;
          }
        }
    
        function keyUpHandler(e) {
          if (e.key === "Right" || e.key === "ArrowRight") {
            //rightPressed = false;
            DkeyDown = false;
          }
          if (e.key === "Left" || e.key === "ArrowLeft") {
            //leftPressed = false;
            AkeyDown = false;
          }
          if (e.key === "Up" || e.key === "ArrowUp") {
            WkeyDown = false;
          }
          if (e.key === "Down" || e.key === "ArrowDown") {
            SkeyDown = false;
          }
    
        }
    
        document.addEventListener("keydown", function(event) {
          if (event.code === "Space") {
          SpaceBarDown = true;
          } if (event.code === "KeyW") {
            //console.log("w");
            WkeyDown2 = true;
          } if (event.code === "KeyS") {
            SkeyDown2 = true;
          } if (event.code === "KeyA") {
            AkeyDown2 = true;
          } if (event.code === "KeyD") {
            DkeyDown2 = true;
          } if (event.code === "ShiftLeft") {
            CtrlKeyDown2 = true;
          } if (event.code === "KeyQ") {
            QKeyDown = true;
          } if (event.code === "KeyE") {
            EKeyDown = true;
          } if (event.code === "Period") {
            LeftVdown = true;
          } if (event.code === "Comma") {
            rightVdown = true;
          }
        });
        document.addEventListener("keyup", function(event) {
          if (event.code === "KeyW") {
            //console.log("w");
            WkeyDown2 = false;
          } if (event.code === "KeyS") {
            SkeyDown2 = false;
          } if (event.code === "KeyA") {
            AkeyDown2 = false;
          } if (event.code === "KeyD") {
            DkeyDown2 = false;
          } if (event.code === "KeyQ") {
            QKeyDown = false;
          } if (event.code === "KeyE") {
            EKeyDown = false;
          } if (event.code === "Period") {
            LeftVdown = false;
          } if (event.code === "Comma") {
            rightVdown = false;
          } 
        }); */
    
        function init() {
          tanks.push(new Tank(100, 100, 1, 0, 0, false, 10, 1));
          tanks.push(new Tank(300, 300, 1, 0, 0, false, 10, 2));
          updateBoard();
        }
    
        init();
      </script>
    </html>
    